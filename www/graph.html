
<link href='http://fonts.googleapis.com/css?family=Lato:300,700' rel='stylesheet' type='text/css'>
<link href='style.css' rel='stylesheet' type='text/css'>

<div id="container">

  </style>
  <div id="graph-container"></div>
  <div id="control-pane">
    <h2 class="underline">filters</h2>

    <div>
      <h3>degree <span id="min-degree-val">0</span></h3>
      0 <input id="min-degree" type="range" min="0" max="0" value="0"> <span id="max-degree-value">0</span><br>
    </div>
    <span class="line"></span>
    <div>
      <h3>clusters</h3>
      <select id="node-category">
        <option value="" selected>All categories</option>
      </select>
    </div>
  </div>
</div>








<script src="js/sigma.min.js"></script>
<script src="js/sigma.layout.forceAtlas2.min.js"></script>
<script src="js/sigma.parsers.json.min.js"></script>
<script src="js/sigma.plugins.dragNodes.min.js"></script>
<script src="js/sigma.plugins.filter.min.js"></script>
<script src="js/sigma.canvas.edges.curvedArrow.js"></script>
<script>


var filter;

function $(id) {
  return document.getElementById(id);
}

function updatePane (graph, filter) {
  // get max degree
  var maxDegree = 0,
      categories = {};

  // read nodes
  graph.nodes().forEach(function(n) {
    maxDegree = Math.max(maxDegree, graph.degree(n.id));
    categories[n.group] = true;
  })

  // min degree
  $('min-degree').max = maxDegree;
  $('max-degree-value').textContent = maxDegree;

  // node category
  var nodecategoryElt = $('node-category');
  Object.keys(categories).forEach(function(c) {
    var optionElt = document.createElement("option");
    optionElt.text = c;
    nodecategoryElt.add(optionElt);
  });
}





function initializeFilter(s) {
  // Initialize the Filter API
  filter = new sigma.plugins.filter(s);

  updatePane(s.graph, filter);

  function applyMinDegreeFilter(e) {
    var v = e.target.value;
    $('min-degree-val').textContent = v;

    filter
      .undo('min-degree')
      .nodesBy(function(n) {
        return this.degree(n.id) >= v;
      }, 'min-degree')
      .apply();
  }

  function applyCategoryFilter(e) {
    var c = e.target[e.target.selectedIndex].value;
    filter
      .undo('node-category')
      .nodesBy(function(n) {
        return !c.length || n.group === c;
      }, 'node-category')
      .apply();
  }

  $('min-degree').addEventListener("input", applyMinDegreeFilter);  // for Chrome and FF
  $('min-degree').addEventListener("change", applyMinDegreeFilter); // for IE10+, that sucks
  $('node-category').addEventListener("change", applyCategoryFilter);
}


instance = new sigma({
  renderer: {
    container: 'graph-container',
    type: 'canvas',
    skipErrors: true
  }
});

sigma.parsers.json('graph.json', instance, () => {
  instance.refresh();
  instance.startForceAtlas2({
    worker: true,
    barnesHutOptimize: true,
    adjustSizes: true,
    slowDown: 50,
    strongGravityMode: true
  });
  setTimeout(() => {
    console.log('Stopping ForceAtlas2');
    instance.killForceAtlas2();
  }, 8000);
  initializeFilter(instance);
});

var dragListener = sigma.plugins.dragNodes(instance, instance.renderers[0]);
dragListener.bind('startdrag', function(event) {
  console.log(event);
});
dragListener.bind('drag', function(event) {
  console.log(event);
});
dragListener.bind('drop', function(event) {
  console.log(event);
});
dragListener.bind('dragend', function(event) {
  console.log(event);
})
</script>
